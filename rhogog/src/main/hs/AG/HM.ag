optpragmas
{
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import Text.Printf (printf)
import Data.List (union,delete,(\\))
import Data.Map (Map)
import qualified Data.Map
import qualified Data.Map as Map
}

-- |Allows types to access themselves.
attr TyS syn it :: self

-- |Represents the type environment where the algorithm W
--  can lookup previously inferred types of variables.
type TyEnv = map {Var} Ty

-- |Represents a stream of fresh type variables. As it is
--  a stream, it should not be allowed to run out.
type TyGen = [TyVar]

{
-- |Simple implementation of a typename generator which first
--  enumerates the alphabet, and then continues with numbered types.
types :: TyGen
types = ['a'..'z']
}

-------------------------------
-- env : Type Environments   --
-------------------------------

attr TmS Ident
  chn env :: TyEnv
  
{
class HasTyEnv a where tyEnv :: a -> TyEnv
instance HasTyEnv Lx where tyEnv lx = env_Syn_Lx $ wrap_Lx (sem_Lx lx) (Inh_Lx Map.empty)
instance HasTyEnv St where tyEnv st = env_Syn_St $ wrap_St (sem_St st) (Inh_St Map.empty)
instance HasTyEnv Tm where tyEnv tm = env_Syn_Tm $ wrap_Tm (sem_Tm tm) (Inh_Tm Map.empty)
}

-------------------------------
-- gen : Type Generalization --
-------------------------------

attr TyS TyEnv
  syn gen :: self
  
sem Ty
  | *   loc.gen = foldr Ty_All @it (@ftv \\ @lhs.ftv)

-------------------------------
-- ftv : Free Type Variables --
-------------------------------
  
attr TyS TyEnv
  syn ftv use {`union`} {[]} :: {[TyVar]}
  inh ftv :: {[TyVar]}
  
sem Ident
  | *  inst.env :: TyEnv
       inst.env = @lhs.env
       ty  .ftv = @env.ftv

sem Ty
  | Var loc.ftv = return @ident
  | App loc.ftv = @ty1.ftv `union` @ty2.ftv
  | All loc.ftv = delete @ident @ty.ftv
  
{
class HasFTV a where ftv :: a -> [TyVar]
instance HasFTV Ty where ftv ty = ftv_Syn_Ty $ wrap_Ty (sem_Ty ty) (Inh_Ty [])
instance HasFTV TyEnv where ftv tyEnv = ftv_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv tyEnv) (Inh_TyEnv [])
}
