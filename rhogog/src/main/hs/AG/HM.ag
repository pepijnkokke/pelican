optpragmas
{
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
}

imports
{
import Data.List (union,delete,(\\))
import Data.Maybe (fromMaybe)
import Data.Map (Map)
import qualified Data.Map
import qualified Data.Map as Map
}

-- |Allows types to access themselves.
attr TyS syn this :: self

-- |Represents the type environment where the algorithm W
--  can lookup previously inferred types of variables.
type TyEnv = map {Var} Ty

{
-- |Represents a stream of fresh type variables. As it is
--  a stream, it should not be allowed to run out.
type TyGen = [TyVar]

-- |Simple implementation of a typename generator which first
--  enumerates the alphabet, and then continues with numbered types.
tyGen :: TyGen
tyGen = ['a'..'z']
}

{
class (HasFTV a) => HasInh a b | a -> b where
  inh :: a -> b
instance HasInh Ty Inh_Ty where
  inh a = Inh_Ty
        { fsh_Inh_Ty      = tyGen \\ ftv a
        , ftv_Inh_Ty      = tyPrim
        , subs_Inh_Ty     = Map.empty
        }
instance HasInh TyEnv Inh_TyEnv where
  inh a = Inh_TyEnv
        { fsh_Inh_TyEnv   = tyGen \\ ftv a
        , ftv_Inh_TyEnv   = tyPrim
        , subs_Inh_TyEnv  = Map.empty
        }
}

-------------------------------
-- env : Type Environments   --
-------------------------------

attr TmS Ident
  chn env :: TyEnv
  
{
class    HasTyEnv ty where tyEnv :: ty -> TyEnv
instance HasTyEnv Lx where tyEnv lx = env_Syn_Lx $ wrap_Lx (sem_Lx lx) (Inh_Lx Map.empty)
instance HasTyEnv St where tyEnv st = env_Syn_St $ wrap_St (sem_St st) (Inh_St Map.empty)
instance HasTyEnv Tm where tyEnv tm = env_Syn_Tm $ wrap_Tm (sem_Tm tm) (Inh_Tm Map.empty)
}

-------------------------------
-- fsh : Fresh-Name Streams  --
-------------------------------

attr TyS TyEnv
  chn fsh :: TyGen
  
sem Ident
  | *   ty .fsh = tyGen \\ @ty.ftv
        env.fsh = tyGen
      
sem Ty
  | App ty1.fsh = @lhs.fsh
        ty2.fsh = @ty1.fsh
        lhs.fsh = @ty2.fsh

{
class    HasFsh ty    where fsh :: ty -> TyGen
instance HasFsh Ty    where fsh ty = fsh_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasFsh TyEnv where fsh ty = fsh_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}        

-------------------------------
-- sub : Type Substitution   --
-------------------------------
{
-- |Represents type substitutions.
type Subst = Map TyVar Ty
}

attr TyS TyEnv
  inh subs :: Subst
  syn subbed :: self
  
sem Ident
  | * ty .subs = Map.empty
      env.subs = Map.empty

sem Ty
  | Var loc.subbed = fromMaybe @this (Map.lookup @ident @lhs.subs)
  
{
class HasSub ty where
  sub     :: Subst -> ty -> ty
  replace :: TyVar -> Ty -> ty -> ty
  replace x ty2 ty1 = sub (Map.singleton x ty2) ty1
  rename  :: TyVar -> TyVar -> ty -> ty
  rename  x  y  ty1 = replace x (Ty_Var y) ty1
instance HasSub Ty where
  sub subs ty = subbed_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasSub TyEnv where
  sub subs ty = subbed_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}

-------------------------------
-- ins : Type Instantiation  --
-------------------------------

attr TyS TyEnv
  syn ins :: self
  
-- substitute fresh names for all bound variables
sem Ty
  | All loc.new = head @lhs.fsh
        ty .fsh = tail @lhs.fsh
        loc.ins = rename @ident @new @ty.ins

{
class    HasIns ty    where ins :: ty -> ty
instance HasIns Ty    where ins ty = ins_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasIns TyEnv where ins ty = ins_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}

-------------------------------
-- gen : Type Generalization --
-------------------------------

attr TyS TyEnv
  syn gen :: self
  
sem Ty
  | * loc.gen = foldr Ty_All @this (@ftv \\ @lhs.ftv)

{
class    HasGen ty    where gen :: ty -> ty
instance HasGen Ty    where gen ty = gen_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasGen TyEnv where gen ty = gen_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}

-------------------------------
-- ftv : Free Type Variables --
-------------------------------
  
attr TyS TyEnv
  chn ftv :: FTV
  
sem Ident
  | * inst.env :: TyEnv
      inst.env = @lhs.env
      ty  .ftv = @env.ftv

sem Ty
  | Var loc.ftv = return @ident
  | App loc.ftv = @ty1.ftv `union` @ty2.ftv
  | All loc.ftv = delete @ident @ty.ftv
  
{
-- |Represents the free (or unbound) type variables in an expression.
type FTV = [TyVar]

class    HasFTV ty    where ftv :: ty -> FTV
instance HasFTV Ty    where ftv ty = ftv_Syn_Ty $ wrap_Ty (sem_Ty ty) ((inh ty) {fsh_Inh_Ty=[]})
instance HasFTV TyEnv where ftv ty = ftv_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) ((inh ty) {fsh_Inh_TyEnv=[]})
}
