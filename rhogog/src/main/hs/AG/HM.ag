optpragmas
{
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
}

imports
{
import Text.Printf (printf)
import Data.List (union,delete,(\\))
import Data.Map (Map)
import qualified Data.Map
import qualified Data.Map as Map
}

-- |Allows types to access themselves.
attr TyS syn it :: self

-- |Represents the type environment where the algorithm W
--  can lookup previously inferred types of variables.
type TyEnv = map {Var} Ty

-- |Represents a stream of fresh type variables. As it is
--  a stream, it should not be allowed to run out.
type TyGen = [TyVar]

{
-- |Simple implementation of a typename generator which first
--  enumerates the alphabet, and then continues with numbered types.
tyGen :: TyGen
tyGen = ['a'..'z']
}

{
-- |Default arguments for type catamorphisms.
inh_ty :: Inh_Ty
inh_ty = Inh_Ty tyGen []

-- |Default arguments for type-environment catamorphisms.
inh_tyEnv :: Inh_TyEnv
inh_tyEnv = Inh_TyEnv tyGen []
}

-------------------------------
-- env : Type Environments   --
-------------------------------

attr TmS Ident
  chn env :: TyEnv
  
{
class HasTyEnv a where tyEnv :: a -> TyEnv
instance HasTyEnv Lx where tyEnv lx = env_Syn_Lx $ wrap_Lx (sem_Lx lx) (Inh_Lx Map.empty)
instance HasTyEnv St where tyEnv st = env_Syn_St $ wrap_St (sem_St st) (Inh_St Map.empty)
instance HasTyEnv Tm where tyEnv tm = env_Syn_Tm $ wrap_Tm (sem_Tm tm) (Inh_Tm Map.empty)
}

-------------------------------
-- fsh : Fresh-Name Streams  --
-------------------------------

attr TyS TyEnv
  inh fsh :: {[TyVar]}
  
sem Ident
  | * env.fsh = tyGen
      ty .fsh = tyGen
  
-------------------------------
-- ins : Type Instantiation  --
-------------------------------

attr TyS TyEnv
  syn ins :: self
  
-- substitute fresh names for all bound variables
sem Ty
  | * loc.ins = foldr Ty_All @it (@ftv \\ @lhs.ftv)

{
class HasIns a where ins :: a -> a
instance HasIns Ty where ins ty = ins_Syn_Ty $ wrap_Ty (sem_Ty ty) inh_ty
instance HasIns TyEnv where ins ty = ins_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) inh_tyEnv
}

-------------------------------
-- gen : Type Generalization --
-------------------------------

attr TyS TyEnv
  syn gen :: self
  
sem Ty
  | * loc.gen = foldr Ty_All @it (@ftv \\ @lhs.ftv)

{
class HasGen a where gen :: a -> a
instance HasGen Ty where gen ty = gen_Syn_Ty $ wrap_Ty (sem_Ty ty) inh_ty
instance HasGen TyEnv where gen ty = gen_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) inh_tyEnv
}

-------------------------------
-- ftv : Free Type Variables --
-------------------------------
  
attr TyS TyEnv
  syn ftv use {`union`} {[]} :: {[TyVar]}
  inh ftv :: {[TyVar]}
  
sem Ident
  | * inst.env :: TyEnv
      inst.env = @lhs.env
      ty  .ftv = @env.ftv

sem Ty
  | Var loc.ftv = return @ident
  | App loc.ftv = @ty1.ftv `union` @ty2.ftv
  | All loc.ftv = delete @ident @ty.ftv
  
{
class HasFTV a where ftv :: a -> [TyVar]
instance HasFTV Ty where ftv ty = ftv_Syn_Ty $ wrap_Ty (sem_Ty ty) inh_ty
instance HasFTV TyEnv where ftv tyEnv = ftv_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv tyEnv) inh_tyEnv
}
