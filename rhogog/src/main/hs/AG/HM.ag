optpragmas
{
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
}

imports
{
import Data.List (union,delete,(\\))
import Data.Maybe (fromMaybe)
import Data.Map (Map)
import qualified Data.Map
import qualified Data.Map as Map
}

-- |Allows types to access themselves.
attr TyS syn this :: self

-- |Represents the type environment where the algorithm W
--  can lookup previously inferred types of variables.
type TyEnv = map {Var} Ty

{
-- |Represents a stream of fresh type variables. As it is
--  a stream, it should not be allowed to run out.
type TyGen = [TyVar]

-- |Simple implementation of a typename generator which first
--  enumerates the alphabet, and then continues with numbered types.
tyGen :: TyGen
tyGen = ['a'..'z']
}

{
class (HasFTV a) => HasInh a b | a -> b where
  inh :: a -> b
instance HasInh Ty Inh_Ty where
  inh a = Inh_Ty
        { fsh_Inh_Ty      = tyGen \\ ftv a
        , ftv_Inh_Ty      = tyPrim
        , subs_Inh_Ty     = I
        }
instance HasInh TyEnv Inh_TyEnv where
  inh a = Inh_TyEnv
        { fsh_Inh_TyEnv   = tyGen \\ ftv a
        , ftv_Inh_TyEnv   = tyPrim
        , subs_Inh_TyEnv  = I
        }
}

---------------------------------
-- env : Type Environments     --
---------------------------------

attr TmS Ident
  chn env :: TyEnv
  
{
class    HasTyEnv ty where tyEnv :: ty -> TyEnv
instance HasTyEnv Lx where tyEnv lx = env_Syn_Lx $ wrap_Lx (sem_Lx lx) (Inh_Lx Map.empty)
instance HasTyEnv St where tyEnv st = env_Syn_St $ wrap_St (sem_St st) (Inh_St Map.empty)
instance HasTyEnv Tm where tyEnv tm = env_Syn_Tm $ wrap_Tm (sem_Tm tm) (Inh_Tm Map.empty)
}

---------------------------------
-- fsh : Fresh-Name Generators --
---------------------------------

attr TyS TyEnv
  chn fsh :: TyGen
  
sem Ident
  | *   ty .fsh = tyGen \\ @ty.ftv
        env.fsh = tyGen
      
sem Ty
  | App ty1.fsh = @lhs.fsh
        ty2.fsh = @ty1.fsh
        lhs.fsh = @ty2.fsh

{
class    HasFsh ty    where fsh :: ty -> TyGen
instance HasFsh Ty    where fsh ty = fsh_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasFsh TyEnv where fsh ty = fsh_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}        

-------------------------------
-- sub : Type Substitution   --
-------------------------------
 
{
-- |Represents type substitutions.
data TySubst
  = I                 -- ^ the identity substitution;
  | S TyVar Ty        -- ^ substitutes the second argument for the first;
  | O TySubst TySubst -- ^ substitution composition.
}

attr TyS TyEnv
  inh subs :: TySubst
  syn subd :: self
  
sem Ident
  | *   ty .subs = I
        env.subs = I
  
sem Ty
  | Var lhs.subd = case @lhs.subs of
                    I       -> @this
                    S x  ty -> if @ident==x then ty else @this
                    O s2 s1 -> subst s2 (subst s1 @this)

{
class HasSub ty where
  subst   :: TySubst -> ty -> ty
  replace :: TyVar -> Ty -> ty -> ty
  replace a b ty = subst (S a b) ty
  rename  :: TyVar -> TyVar -> ty -> ty
  rename  a b ty = replace a (Ty_Var b) ty
instance HasSub Ty where
  subst s ty = subd_Syn_Ty $ wrap_Ty (sem_Ty ty) ((inh ty) {subs_Inh_Ty=s})
instance HasSub TyEnv where
  subst s ty = fmap (subst s) ty
}

-------------------------------
-- ins : Type Instantiation  --
-------------------------------

attr TyS TyEnv
  syn ins :: self

sem Ty
  | All loc.new = head @ty.fsh
        lhs.fsh = tail @ty.fsh
        loc.ins = rename @ident @new @ty.ins

{
class    HasIns ty    where ins :: ty -> ty
instance HasIns Ty    where ins ty = ins_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasIns TyEnv where ins ty = ins_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}

-------------------------------
-- gen : Type Generalization --
-------------------------------

attr TyS TyEnv
  syn gen :: self
  
sem Ty
  | * loc.gen = foldr Ty_All @this (@ftv \\ @lhs.ftv)

{
class    HasGen ty    where gen :: ty -> ty
instance HasGen Ty    where gen ty = gen_Syn_Ty $ wrap_Ty (sem_Ty ty) (inh ty)
instance HasGen TyEnv where gen ty = gen_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) (inh ty)
}

-------------------------------
-- ftv : Free Type Variables --
-------------------------------
{ 
-- |Represents the free (or unbound) type variables in an expression.
type FTV = [TyVar]
}
 
attr TyS TyEnv
  chn ftv :: FTV
  
sem Ident
  | * inst.env :: TyEnv
      inst.env = @lhs.env
      ty  .ftv = @env.ftv

sem Ty
  | Var loc.ftv = return @ident
  | App loc.ftv = @ty1.ftv `union` @ty2.ftv
  | All loc.ftv = delete @ident @ty.ftv
  
{
class    HasFTV ty    where ftv :: ty -> FTV
instance HasFTV Ty    where ftv ty = ftv_Syn_Ty $ wrap_Ty (sem_Ty ty) ((inh ty) {fsh_Inh_Ty=[]})
instance HasFTV TyEnv where ftv ty = ftv_Syn_TyEnv $ wrap_TyEnv (sem_TyEnv ty) ((inh ty) {fsh_Inh_TyEnv=[]})
}
